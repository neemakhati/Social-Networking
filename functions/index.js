const functions = require("firebase-functions");
const admin = require("firebase-admin");
admin.initializeApp();
const firestore = admin.firestore();
const eventsCollection = firestore.collection("Events");
// Create an event
exports.createEvent = functions.https.onRequest((req, res) => {
  const event = req.body; // Assuming the request body contains the event data
  // Save the event to Firestore with the default doc ID generated by Firebase
  eventsCollection
      .add(event)
      .then((ref) => {
        res.status(201).json({
          id: ref.id,
          message: "Event created successfully",
        });
      })
      .catch((error) => {
        res.status(500).json({error: "Failed to create event"});
      });
});
// Read all events
exports.getEvents = functions.https.onRequest((req, res) => {
  const location = req.query.location;
  let query = eventsCollection;
  if (location) {
    query = query.where("Location", "==", location);
  }
  query
      .get()
      .then((snapshot) => {
        const events = [];
        snapshot.forEach((doc) => {
          const event = {
            id: doc.id,
            ...doc.data(),
          };
          events.push(event);
        });
        res.status(200).json(events);
      })
      .catch((error) => {
        console.error("Failed to fetch events:", error);
        res.status(500).json({error: "Failed to fetch events"});
      });
});

// Read a single event
exports.getEvent = functions.https.onRequest((req, res) => {
  const eventId = req.query.id; // Assuming the event ID i
  if (!eventId) {
    res.status(400).json({error: "Event ID is missing"});
    return;
  }
  eventsCollection
      .doc(eventId)
      .get()
      .then((doc) => {
        if (doc.exists) {
          const event = {
            id: doc.id,
            ...doc.data(),
          };
          res.status(200).json(event);
        } else {
          res.status(404).json({error: "Event not found"});
        }
      })
      .catch((error) => {
        console.error("Failed to fetch event:", error);
        res.status(500).json({error: "Failed to fetch event"});
      });
});
// Update an event
exports.updateEvent = functions.https.onRequest((req, res) => {
  const eventId = req.params.id; // Assuming
  const updatedEvent = req.body; // Assuming
  eventsCollection
      .doc(eventId)
      .update(updatedEvent)
      .then(() => {
        res.status(200).json({message: "Event updated successfully"});
      })
      .catch((error) => {
        res.status(500).json({error: "Failed to update event"});
      });
});
// Delete an event
exports.deleteEvent = functions.https.onRequest((req, res) => {
  const eventId = req.query.id; //
  if (!eventId) {
    return res.status(400).json({
      error: "Event ID is missing in the query parameters"});
  }

  eventsCollection
      .doc(eventId)
      .delete()
      .then(() => {
        res.status(200).json({message: "Event deleted successfully"});
      })
      .catch((error) => {
        res.status(500).json({error: "Failed to delete event"});
      });
});


exports.getRecommendation = functions.https.onRequest(async (req, res) => {
  try {
    const {id} = req.query;
    if (!id) {
      throw new Error("Event ID is missing in the query parameters.");
    }

    const eventIds = id.split(",");
    if (eventIds.length === 0) {
      throw new Error("No event IDs provided in the query parameters.");
    }

    const requestedEventSnapshot = await eventsCollection.doc(
        eventIds[0]).get();
    if (!requestedEventSnapshot.exists) {
      throw new Error("Requested event does not exist in the database.");
    }

    const requestedEventData = requestedEventSnapshot.data();
    if (!requestedEventData || !requestedEventData.Genre) {
      throw new Error("Requested event data or Genre is missing or undefined.");
    }

    const allEventsSnapshot = await eventsCollection.get();
    const allEventsData = allEventsSnapshot.docs.map((doc) => doc.data());
    if (!allEventsData || allEventsData.length === 0) {
      throw new Error("No events found in the database.");
    }

    // Count the number of genres in the requested events
    const genresCount = {};
    for (const eventId of eventIds) {
      const eventSnapshot = await eventsCollection.doc(eventId).get();
      const eventData = eventSnapshot.data();
      if (eventData && eventData.Genre) {
        const genres = eventData.Genre.split(",");
        for (const genre of genres) {
          if (genresCount[genre]) {
            genresCount[genre]++;
          } else {
            genresCount[genre] = 1;
          }
        }
      }
    }

    const recommendedEvents = allEventsData
        .map((event) => ({
          ...event,
          similarityScore: calculateSimilarity(
              requestedEventData.Genre, event.Genre),
        }))
        .filter((event) => !eventIds.includes(event.id))
        .sort((a, b) => b.similarityScore - a.similarityScore)
        .filter((event) => {
        // Check if the event's genre is within the desired distribution
          const genres = event.Genre.split(",");
          for (const genre of genres) {
            if (genresCount[genre] && genresCount[genre] > 0) {
              genresCount[genre]--;
              return true;
            }
          }
          return false;
        })
        .slice(0, 5);

    res.status(200).json(recommendedEvents);
  } catch (error) {
    console.error("Error retrieving recommended events:", error);
    res.status(500).send("Internal server error");
  }
});

// Helper function to calculate similarity based on Genre
function calculateSimilarity(genreA, genreB) {
  const genreArrayA = genreA ? genreA.split(",") : [];
  const genreArrayB = genreB ? genreB.split(",") : [];
  // Find common genres
  const commonGenres = genreArrayA.filter((genre) =>
    genreArrayB.includes(genre));
  // Calculate similarity score based on the number of common genres
  const similarityScore = commonGenres.length / Math.sqrt(
      genreArrayA.length * genreArrayB.length);
  return similarityScore;
}
