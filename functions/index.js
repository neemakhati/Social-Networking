const functions = require("firebase-functions");
const admin = require("firebase-admin");
admin.initializeApp();
const firestore = admin.firestore();
const eventsCollection = firestore.collection("Events");

// Create an event
exports.createEvent = functions.https.onRequest((req, res) => {
  const event = req.body; // Assuming the request body contains the event data
  // Save the event to Firestore with the default doc ID generated by Firebase
  eventsCollection
      .add(event)
      .then((ref) => {
        res.status(201).json({
          id: ref.id,
          message: "Event created successfully",
        });
      })
      .catch((error) => {
        res.status(500).json({error: "Failed to create event"});
      });
});
// Read all events
exports.getEvents = functions.https.onRequest((req, res) => {
  const location = req.query.location;
  let query = eventsCollection;
  if (location) {
    query = query.where("Location", "==", location);
  }
  query
      .get()
      .then((snapshot) => {
        const events = [];
        snapshot.forEach((doc) => {
          const event = {
            id: doc.id,
            ...doc.data(),
          };
          events.push(event);
        });
        res.status(200).json(events);
      })
      .catch((error) => {
        console.error("Failed to fetch events:", error);
        res.status(500).json({error: "Failed to fetch events"});
      });
});

// Read a single event
exports.getEvent = functions.https.onRequest((req, res) => {
  const eventId = req.query.id; // Assuming the event ID i
  if (!eventId) {
    res.status(400).json({error: "Event ID is missing"});
    return;
  }
  eventsCollection
      .doc(eventId)
      .get()
      .then((doc) => {
        if (doc.exists) {
          const event = {
            id: doc.id,
            ...doc.data(),
          };
          res.status(200).json(event);
        } else {
          res.status(404).json({error: "Event not found"});
        }
      })
      .catch((error) => {
        console.error("Failed to fetch event:", error);
        res.status(500).json({error: "Failed to fetch event"});
      });
});
// Update an event
// Update an event
exports.updateEvent = functions.https.onRequest((req, res) => {
  const eventId = req.query.id; // Get event ID from query parameters
  const updatedEvent = req.body; // Get updated event data from request body

  eventsCollection
      .doc(eventId)
      .update(updatedEvent)
      .then(() => {
        res.status(200).json({message: "Event updated successfully"});
      })
      .catch((error) => {
        res.status(500).json({error: "Failed to update event"});
      });
});

// Delete an event
exports.deleteEvent = functions.https.onRequest((req, res) => {
  const eventId = req.query.id; //
  if (!eventId) {
    return res.status(400).json({
      error: "Event ID is missing in the query parameters"});
  }

  eventsCollection
      .doc(eventId)
      .delete()
      .then(() => {
        res.status(200).json({message: "Event deleted successfully"});
      })
      .catch((error) => {
        res.status(500).json({error: "Failed to delete event"});
      });
});


// index.js

exports.getRecommendedEvents = functions.https.onRequest(async (req, res) => {
  try {
    const {id} = req.query;
    console.log("Requested event IDs:", id);

    const eventIds = id.split(",");
    console.log("Split event IDs:", eventIds);

    const allEventsSnapshot = await eventsCollection.get();
    const allEventsData = allEventsSnapshot.docs.map((doc) => doc.data());
    console.log("All events data:", allEventsData);

    const requestedEventsData = [];

    // Fetch data for the requested events
    for (const eventId of eventIds) {
      console.log("Fetching event data for event ID:", eventId);
      const eventSnapshot = await eventsCollection.doc(eventId).get();
      const eventData = eventSnapshot.data();
      if (eventData) {
        console.log("Event data for event ID", eventId, ":", eventData);
        requestedEventsData.push(eventData);
      } else {
        console.log("Event data not found for event ID:", eventId);
      }
    }

    console.log("Requested events data:", requestedEventsData);

    const recommendedEvents = allEventsData
        .map((event) => ({
          ...event,
          similarityScore: calculateSimilarity(requestedEventsData, event),
        }))
        .filter((event) => !eventIds.includes(event.id))
        .sort((a, b) => b.similarityScore - a.similarityScore)
        .slice(0, 6); // Limit to a maximum of 6 recommendations

    console.log("Recommended events:", recommendedEvents);
    res.status(200).json(recommendedEvents);
  } catch (error) {
    console.error("Error retrieving recommended events:", error);
    res.status(500).send("Internal server error");
  }
});

function calculateSimilarity(requestedEventsData, eventB) {
  if (!eventB || !eventB.Genre) {
    // Return a default similarity score
    // (e.g., 0) when eventB or its Genre property is not available
    return 0;
  }

  const genreArrayB = eventB.Genre.split(",");
  let totalSimilarityScore = 0;

  for (const requestedEvent of requestedEventsData) {
    const genreArrayA = requestedEvent.Genre.split(",");
    // Find common genres
    const commonGenres = genreArrayA.filter((genre) =>
      genreArrayB.includes(genre),
    );
    // Calculate similarity score based on the number of common genres
    const similarityScore =
      commonGenres.length / Math.sqrt(genreArrayA.length * genreArrayB.length);
    totalSimilarityScore += similarityScore;
  }

  const averageSimilarityScore =
    totalSimilarityScore / requestedEventsData.length;
  return averageSimilarityScore;
}
